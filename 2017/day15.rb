# Day 15: Dueling Generators

require 'test/unit/assertions'

include Test::Unit::Assertions

GENERATOR_A_START = 883
GENERATOR_B_START = 879
TEST_GENERATOR_A_START = 65
TEST_GENERATOR_B_START = 8921

GENERATOR_A_FACTOR = 16807
GENERATOR_B_FACTOR = 48271

DIVISOR = 2147483647
NUM_PAIRS_PART_ONE = 40000000
NUM_PAIRS_PART_TWO = 5000000
TEST_NUM_PAIRS_PART_ONE = 5
TEST_NUM_PAIRS_PART_TWO = 1056

def has_last_16_bit_match(a, b)
  # Returns whether two numbers have the same lowest 16 bits

  bin_a = a.to_s(2).rjust(16, "0")[-16..]
  bin_b = b.to_s(2).rjust(16, "0")[-16..]
  bin_a == bin_b
end

def get_num_pairs_part_one(gen_a_start, gen_a_factor, gen_b_start, gen_b_factor, divisor, num_pairs)
  # Returns the number of pairs generated by Generator A and B that
  # have the same lowest 16 bits within the first x pairs
  
  # Each generator takes the previous value and multiplies by a factor, 
  # then divides the product by a divisor and keeps the remainder as 
  # the next value.

  val_a = gen_a_start
  val_b = gen_b_start
  count = 0
  num_pairs.times do
    val_a = (val_a * gen_a_factor) % divisor
    val_b = (val_b * gen_b_factor) % divisor
    count += 1 if has_last_16_bit_match(val_a, val_b)
  end
  return count
end 

def get_num_pairs_part_two(gen_a_start, gen_a_factor, gen_b_start, gen_b_factor, divisor, num_pairs)
  # Returns the number of pairs generated by Generator A and B that
  # have the same lowest 16 bits within the first x pairs
  
  # Each generator takes the previous value and multiplies by a factor, 
  # then divides the product by a divisor and keeps the remainder as 
  # the next value. However Generator A only passes the value to be compared
  # when it is divisible by 4 and Generator B only passes the value when 
  # it is divisible by 8.

  val_a = gen_a_start
  val_b = gen_b_start
  gen_a_vals = []
  gen_b_vals = []
  count = 0
  until gen_a_vals.length == num_pairs && gen_b_vals.length == num_pairs
    if gen_a_vals.length < num_pairs
      val_a = (val_a * gen_a_factor) % divisor
      gen_a_vals << val_a if val_a % 4 == 0 
    end
    if gen_b_vals.length < num_pairs
      val_b = (val_b * gen_b_factor) % divisor
      gen_b_vals << val_b if val_b % 8 == 0 
    end 
  end 

  num_pairs.times { |i| count += 1 if has_last_16_bit_match(gen_a_vals[i], gen_b_vals[i]) } 
  return count
end 


def solve_part_one(gen_a_start, gen_a_factor, gen_b_start, gen_b_factor, divisor, num_pairs)
  get_num_pairs_part_one(gen_a_start, gen_a_factor, gen_b_start, gen_b_factor, divisor, num_pairs)
end

def solve_part_two(gen_a_start, gen_a_factor, gen_b_start, gen_b_factor, divisor, num_pairs)
  get_num_pairs_part_two(gen_a_start, gen_a_factor, gen_b_start, gen_b_factor, divisor, num_pairs)
end

def main
  assert solve_part_one(TEST_GENERATOR_A_START, GENERATOR_A_FACTOR, TEST_GENERATOR_B_START, GENERATOR_B_FACTOR, DIVISOR, TEST_NUM_PAIRS_PART_ONE) == 1
  assert solve_part_two(TEST_GENERATOR_A_START, GENERATOR_A_FACTOR, TEST_GENERATOR_B_START, GENERATOR_B_FACTOR, DIVISOR, TEST_NUM_PAIRS_PART_ONE) == 0
  assert solve_part_two(TEST_GENERATOR_A_START, GENERATOR_A_FACTOR, TEST_GENERATOR_B_START, GENERATOR_B_FACTOR, DIVISOR, TEST_NUM_PAIRS_PART_TWO) == 1

  puts "Part One: #{solve_part_one(GENERATOR_A_START, GENERATOR_A_FACTOR, GENERATOR_B_START, GENERATOR_B_FACTOR, DIVISOR, NUM_PAIRS_PART_ONE)}"
  puts "Part Two: #{solve_part_two(GENERATOR_A_START, GENERATOR_A_FACTOR, GENERATOR_B_START, GENERATOR_B_FACTOR, DIVISOR, NUM_PAIRS_PART_TWO)}"
end

main